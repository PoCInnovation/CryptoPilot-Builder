#!/usr/bin/env python3
"""
Tests d'int√©gration pour les collecteurs unifi√©s
Valide que les collecteurs de donn√©es et de news sont correctement fusionn√©s
"""

import sys
import os
import asyncio
import unittest
from datetime import datetime, timedelta
from unittest.mock import patch, MagicMock

# Ajouter le r√©pertoire parent au path Python
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from pipeline.agents.trading.unified_data_collector import UnifiedDataCollectorAgent
from services.news_service import news_service, NewsItem
from services.ai_analyzer import ai_analyzer, MarketContext
from services.autowallet_service import autowallet_service

class TestUnifiedCollectors(unittest.TestCase):
    """Tests pour les collecteurs unifi√©s"""
    
    def setUp(self):
        """Configuration des tests"""
        self.unified_collector = UnifiedDataCollectorAgent()
        self.test_user_id = "test_user_unified_123"
        
    def tearDown(self):
        """Nettoyage apr√®s les tests"""
        # Nettoyer les donn√©es de test
        try:
            autowallet_service.delete_autowallet(self.test_user_id)
        except:
            pass
    
    def test_unified_collector_initialization(self):
        """Test l'initialisation du collecteur unifi√©"""
        print("üß™ Test d'initialisation du collecteur unifi√©...")
        
        # V√©rifier que le collecteur est correctement initialis√©
        self.assertIsNotNone(self.unified_collector)
        self.assertEqual(self.unified_collector.name, "unified_data_collector")
        self.assertIsNotNone(self.unified_collector.circuit_breaker)
        self.assertIsNotNone(self.unified_collector.cryptos)
        
        # V√©rifier les cryptos surveill√©es
        expected_cryptos = ["bitcoin", "ethereum", "cardano", "polkadot", "solana"]
        for crypto in expected_cryptos:
            self.assertIn(crypto, self.unified_collector.cryptos)
        
        print("‚úÖ Collecteur unifi√© initialis√© correctement")
    
    def test_news_collection_integration(self):
        """Test l'int√©gration de la collecte de news"""
        print("üß™ Test d'int√©gration de la collecte de news...")
        
        try:
            # R√©cup√©rer des news r√©centes
            recent_news = news_service.get_recent_news(hours=24)
            
            # V√©rifier que des news sont r√©cup√©r√©es
            self.assertIsInstance(recent_news, list)
            print(f"‚úÖ {len(recent_news)} news r√©cup√©r√©es")
            
            if recent_news:
                # V√©rifier la structure des news
                news_item = recent_news[0]
                self.assertIsInstance(news_item, NewsItem)
                self.assertIsNotNone(news_item.id)
                self.assertIsNotNone(news_item.title)
                self.assertIsNotNone(news_item.content)
                self.assertIsNotNone(news_item.source)
                self.assertIsNotNone(news_item.published_at)
                
                print(f"‚úÖ Structure des news valid√©e: {news_item.title[:50]}...")
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Erreur lors de la collecte de news: {e}")
            # Ne pas faire √©chouer le test si l'API externe n'est pas disponible
    
    def test_ai_analyzer_integration(self):
        """Test l'int√©gration de l'analyseur IA"""
        print("üß™ Test d'int√©gration de l'analyseur IA...")
        
        try:
            # Cr√©er des news de test
            test_news = [
                NewsItem(
                    id="test_news_1",
                    title="Bitcoin atteint de nouveaux sommets historiques",
                    content="Le Bitcoin continue sa progression avec une adoption institutionnelle croissante.",
                    source="Test Source",
                    published_at=datetime.now(),
                    url="https://test.com/btc-news",
                    sentiment_score=0.7,
                    relevance_score=0.8,
                    crypto_mentions=["BTC"],
                    impact_level="high"
                )
            ]
            
            # Analyser les news
            market_context = ai_analyzer.get_market_context()
            alerts = ai_analyzer.analyze_news_for_investment(test_news, market_context)
            
            # V√©rifier que des alertes sont g√©n√©r√©es
            self.assertIsInstance(alerts, list)
            print(f"‚úÖ {len(alerts)} alertes g√©n√©r√©es")
            
            if alerts:
                alert = alerts[0]
                self.assertIsNotNone(alert.id)
                self.assertIsNotNone(alert.crypto_symbol)
                self.assertIn(alert.alert_type, ["buy", "sell", "hold"])
                self.assertGreaterEqual(alert.confidence_score, 0.0)
                self.assertLessEqual(alert.confidence_score, 1.0)
                self.assertIsNotNone(alert.reasoning)
                
                print(f"‚úÖ Alerte g√©n√©r√©e: {alert.alert_type} {alert.crypto_symbol} ({alert.confidence_score:.2f})")
            
        except Exception as e:
            print(f"‚ùå Erreur lors de l'analyse IA: {e}")
            self.fail(f"L'analyseur IA a √©chou√©: {e}")
    
    def test_autowallet_service_integration(self):
        """Test l'int√©gration avec le service autowallet"""
        print("üß™ Test d'int√©gration avec le service autowallet...")
        
        try:
            # Cr√©er une configuration de test
            test_config = {
                'is_active': True,
                'analysis_interval': 5,
                'max_investment_per_trade': 50.0,
                'risk_tolerance': 'low',
                'investment_strategy': 'conservative',
                'min_confidence_threshold': 0.8,
                'crypto_whitelist': ['BTC', 'ETH']
            }
            
            # Cr√©er l'autowallet
            autowallet_id = autowallet_service.create_autowallet(self.test_user_id, test_config)
            self.assertIsNotNone(autowallet_id)
            print(f"‚úÖ Autowallet cr√©√©: {autowallet_id}")
            
            # V√©rifier le statut
            status = autowallet_service.get_autowallet_status(self.test_user_id)
            self.assertIsInstance(status, dict)
            self.assertTrue(status.get('is_active', False))
            print(f"‚úÖ Statut v√©rifi√©: {status['is_active']}")
            
            # Tester l'analyse manuelle
            alerts = autowallet_service.analyze_news_manually(self.test_user_id, ["test_news_1"])
            self.assertIsInstance(alerts, list)
            print(f"‚úÖ Analyse manuelle: {len(alerts)} alertes")
            
        except Exception as e:
            print(f"‚ùå Erreur lors de l'int√©gration autowallet: {e}")
            self.fail(f"L'int√©gration autowallet a √©chou√©: {e}")
    
    @patch('pipeline.agents.trading.unified_data_collector.market_data_service')
    async def test_unified_data_collection_simulation(self, mock_market_service):
        """Test la simulation de collecte de donn√©es unifi√©es"""
        print("üß™ Test de simulation de collecte de donn√©es unifi√©es...")
        
        # Mock des donn√©es de march√©
        mock_market_service.get_crypto_price.return_value = 50000.0
        
        try:
            # Simuler la collecte de donn√©es crypto
            crypto_data = await self.unified_collector._collect_crypto_data(
                None, "bitcoin", "BTC"
            )
            
            if crypto_data:
                self.assertIsInstance(crypto_data, dict)
                self.assertIn("symbol", crypto_data)
                self.assertIn("price", crypto_data)
                self.assertEqual(crypto_data["symbol"], "BTC")
                print(f"‚úÖ Donn√©es crypto collect√©es: {crypto_data['symbol']} = ${crypto_data['price']}")
            
            # Simuler la collecte de news
            news_data = await self.unified_collector._collect_news_data(None)
            self.assertIsInstance(news_data, list)
            print(f"‚úÖ {len(news_data)} news collect√©es")
            
            # Simuler l'analyse des news
            alerts_data = await self.unified_collector._analyze_news_for_alerts(None, news_data)
            self.assertIsInstance(alerts_data, list)
            print(f"‚úÖ {len(alerts_data)} alertes g√©n√©r√©es")
            
        except Exception as e:
            print(f"‚ùå Erreur lors de la simulation: {e}")
            self.fail(f"La simulation de collecte a √©chou√©: {e}")
    
    def test_pipeline_manager_integration(self):
        """Test l'int√©gration avec le pipeline manager"""
        print("üß™ Test d'int√©gration avec le pipeline manager...")
        
        try:
            from pipeline.utils.pipeline_manager import PipelineManager
            
            # Cr√©er le pipeline manager
            pipeline_manager = PipelineManager()
            
            # V√©rifier que le collecteur unifi√© est dans les agents
            self.assertIn("unified_data_collector", pipeline_manager.agents)
            print("‚úÖ Collecteur unifi√© int√©gr√© au pipeline manager")
            
            # V√©rifier le statut des agents
            agent_status = pipeline_manager.agent_status
            self.assertIn("unified_data_collector", agent_status)
            print("‚úÖ Statut des agents initialis√©")
            
            # Tester l'ex√©cution synchrone du collecteur unifi√©
            unified_data = pipeline_manager._execute_unified_data_collector_sync()
            if unified_data:
                self.assertIsInstance(unified_data, dict)
                self.assertIn("market_data", unified_data)
                self.assertIn("news_data", unified_data)
                self.assertIn("alerts_data", unified_data)
                print("‚úÖ Ex√©cution synchrone du collecteur unifi√© r√©ussie")
            
        except Exception as e:
            print(f"‚ùå Erreur lors de l'int√©gration pipeline manager: {e}")
            self.fail(f"L'int√©gration pipeline manager a √©chou√©: {e}")
    
    def test_error_handling_and_logging(self):
        """Test la gestion d'erreurs et le logging"""
        print("üß™ Test de gestion d'erreurs et logging...")
        
        try:
            # Tester avec des donn√©es invalides
            invalid_news_data = [
                {
                    "id": "invalid_news",
                    "title": None,  # Donn√©es invalides
                    "content": None,
                    "source": None,
                    "published_at": "invalid_date",
                    "url": None,
                    "sentiment_score": "invalid",
                    "relevance_score": "invalid",
                    "crypto_mentions": None,
                    "impact_level": None
                }
            ]
            
            # L'analyseur devrait g√©rer les erreurs gracieusement
            market_context = ai_analyzer.get_market_context()
            alerts = ai_analyzer.analyze_news_for_investment([], market_context)
            self.assertIsInstance(alerts, list)
            print("‚úÖ Gestion d'erreurs avec donn√©es vides")
            
            # Tester le circuit breaker
            circuit_breaker = self.unified_collector.circuit_breaker
            self.assertIsNotNone(circuit_breaker)
            print("‚úÖ Circuit breaker initialis√©")
            
        except Exception as e:
            print(f"‚ùå Erreur lors du test de gestion d'erreurs: {e}")
            self.fail(f"La gestion d'erreurs a √©chou√©: {e}")

def run_integration_tests():
    """Lance tous les tests d'int√©gration"""
    print("üöÄ D√©marrage des tests d'int√©gration pour les collecteurs unifi√©s")
    print("=" * 70)
    
    # Cr√©er la suite de tests
    test_suite = unittest.TestLoader().loadTestsFromTestCase(TestUnifiedCollectors)
    
    # Ex√©cuter les tests
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(test_suite)
    
    # R√©sum√© des r√©sultats
    print("\n" + "=" * 70)
    print("üìä R√âSUM√â DES TESTS D'INT√âGRATION")
    print("=" * 70)
    
    total_tests = result.testsRun
    failures = len(result.failures)
    errors = len(result.errors)
    successes = total_tests - failures - errors
    
    print(f"Tests ex√©cut√©s: {total_tests}")
    print(f"‚úÖ R√©ussis: {successes}")
    print(f"‚ùå √âchecs: {failures}")
    print(f"üí• Erreurs: {errors}")
    
    if failures > 0:
        print("\nüîç D√âTAILS DES √âCHECS:")
        for test, traceback in result.failures:
            print(f"  - {test}: {traceback.split('AssertionError: ')[-1].split('\\n')[0]}")
    
    if errors > 0:
        print("\nüí• D√âTAILS DES ERREURS:")
        for test, traceback in result.errors:
            print(f"  - {test}: {traceback.split('\\n')[-2]}")
    
    success_rate = (successes / total_tests) * 100 if total_tests > 0 else 0
    print(f"\nüìà Taux de r√©ussite: {success_rate:.1f}%")
    
    if success_rate >= 80:
        print("üéâ Tests d'int√©gration r√©ussis ! Les collecteurs sont correctement fusionn√©s.")
        return 0
    else:
        print("‚ö†Ô∏è  Certains tests ont √©chou√©. V√©rifiez la configuration.")
        return 1

if __name__ == "__main__":
    exit_code = run_integration_tests()
    sys.exit(exit_code)
